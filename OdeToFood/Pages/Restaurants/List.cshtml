@page 

@model OdeToFood.ListModel
@{
    ViewData["Title"] = "List";
}

<!--Razor Pages default with "at-page" only to note it's a Razor Page-->
<!--And with that comes some other defaults, like how URLs are written.-->
<!--To let the page understand other URL formats, like default "/Detail?restaurantId=2" vs "/Detail/2"-->
<!--you need to add some extra code (which you did, requiring an int at the end of the /Detail/)-->

<!--Hmm You tried to make it 'at-page "{restaurantId:int}" just like in the video.-->
<!--It made the entire /List page give a 404 error. So... something is wrong.-->
<!--If it ever does work, though, the id of "restaurantId" come from your label of "asp-route-restaurantId="-->

<h1>Restaurants</h1>
<h3>That defaulted to List, presumably based on the name of the model.</h3>

<p>
    The at signs are directives. At-page means it's a Razor Page. At-model identifies the model -- ie,
    this will show an instance of the ListModel class. The ListModel class is found in the .cs file behind this page.
</p>
<p>More generally, the at sign shows a transition between writing html and C#.</p>
<p>So this page is like the view in MVC and the .cs file is like the model.</p>
<br />

@Model.Message
<!--That references the matching model (the .cs file) and does the thing.-->
<!--Another example... Check appsettings.json where you added a Message.-->
<!--Next, check the .cs where you added a constructor that will bring in the configuration.
    Too bad it's not more clear that config is appsettings.json, but now you know.-->
<!--In that OnGet() method, you've addede a new Message2 that says "check the config for the key Message-->
@Model.Message2

<br />

<!--After you set up the .cs with some logic to GetAll(), the data is available to display here.-->
<!--Note how you're switching back a forth between html and CS here.-->
<!--Restaurants refers to Restaurants = restaurantData.GetAll(); in the .cs-->
<!--.Name etc are the properties of each one.-->
<h1>List of restaurants</h1>
<table class="table">
    @foreach (var restaurant in Model.Restaurants)
    {
        <tr>
            <td>@restaurant.Name</td>
            <td>@restaurant.Location</td>
            <td>@restaurant.Cuisine</td>
            <td>
                @*<a class="btn-outline-warning btn-lg" href="/Restaurants/Detail?restaurantId=@restaurant.Id">*@
                <!--that was one way. another way using asp-page:-->
                <a class="btn-outline-warning btn-lg" asp-page="./Detail" asp-route-restaurantId="@restaurant.Id">
                    <i class="glyphicon glyphicon-zoom-in">Details</i>
                </a>
                <a class="btn-outline-warning btn-lg" asp-page="./Edit" asp-route-restaurantId="@restaurant.Id">
                    <i class="glyphicon glyphicon-edit">Edit</i>
                </a>
            </td>
        </tr>
    }

</table>

<!--Module Two about Model Binding. We'll start with a form.-->
<!--"form" tabtab--> <!--starts with POST but we want GET-->
<!--the html is where you set up to get what a user inputs. this is just a search bar.-->
<!--IRestaurantData is where you'll start the logic for what to do with the search.-->
<form method="get">
    <div class="form-group">
        <div class="input-group">
            @*<input type="search" class="form-control" value="" name="searchTerm"/>*@
            <!--searchTerm is what will link this input to the logic that you also name searchTerm-->
            <input type="search" class="form-control" asp-for="SearchTerm" />
            <!--instead of searchTerm as input only, you have SearchTerm as input/output.-->
            <span class="input-group-btn">
                <button class="btn btn-default">
                    <i class="glyphicon glyphicon-search"></i>
                </button>
            </span>
        </div>
    </div>

</form>